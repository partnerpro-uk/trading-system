# AI-Augmented Forex Trading System

## Technical Specification

---

## Tech Stack Overview

| Layer | Technology | Why |
|-------|------------|-----|
| **Frontend** | React 18+ with TypeScript | Industry standard, type safety |
| **Framework** | Next.js 14 (App Router) | File-based routing, API routes, Vercel deployment |
| **Styling** | Tailwind CSS | Rapid UI development, utility-first |
| **Charts** | TradingView Lightweight Charts v5 | Open source, 35kb, extensible via plugins |
| **Backend/Database** | Convex | Real-time subscriptions, TypeScript native, serverless |
| **Broker Data** | OANDA v20 API | Free demo, streaming prices, historical back to 2005 |
| **AI Provider** | Claude API (Direct) | Primary — best reasoning, context handling |
| **AI Alternative** | OpenRouter | Optional — model flexibility, fallback |
| **Auth** | Convex Auth or Clerk | Convex-compatible authentication |
| **Hosting** | Vercel | Seamless Next.js deployment, edge functions |
| **File Storage** | Convex File Storage | Screenshots, voice notes |
| **State Management** | Zustand | Lightweight, TypeScript-friendly |

### AI Provider Decision

**Claude Direct (Recommended for MVP):**
- Lowest latency
- Full feature access, newest capabilities first
- Direct relationship with Anthropic
- Best for: Core analysis, reasoning tasks

**OpenRouter (Consider Later):**
- Can swap models without code changes
- Useful for cost optimization on simple tasks
- Fallback if Claude API has issues
- Best for: Experimentation, cheaper auxiliary tasks

```typescript
// Easy to swap later with abstraction
interface AIProvider {
  analyze(prompt: string, context: any): Promise<string>;
}

class ClaudeProvider implements AIProvider { /* ... */ }
class OpenRouterProvider implements AIProvider { /* ... */ }
```

---

## Project Structure

```
trading-system/
├── convex/
│   ├── _generated/               # Auto-generated by Convex
│   ├── schema.ts                 # Database schema (see below)
│   ├── candles.ts                # Candle data mutations/queries
│   ├── trades.ts                 # Trade log mutations/queries
│   ├── strategies.ts             # Strategy CRUD
│   ├── analysis.ts               # Claude API integration
│   ├── indicators.ts             # Indicator calculations
│   ├── sessionLevels.ts          # Session high/low calculations
│   ├── htfLevels.ts              # Higher timeframe levels
│   ├── fvg.ts                    # Fair value gap detection
│   ├── sweeps.ts                 # Liquidity sweep detection
│   ├── backtests.ts              # Backtesting engine
│   ├── oanda.ts                  # OANDA API actions
│   ├── news.ts                   # News event tracking
│   └── crons.ts                  # Scheduled jobs (candle fetching)
│
├── src/
│   ├── app/
│   │   ├── layout.tsx
│   │   ├── page.tsx              # Dashboard
│   │   ├── chart/
│   │   │   └── [pair]/page.tsx   # Live chart view
│   │   ├── trades/
│   │   │   └── page.tsx          # Trade log
│   │   ├── backtest/
│   │   │   └── page.tsx          # Backtesting UI
│   │   ├── strategies/
│   │   │   └── page.tsx          # Strategy editor
│   │   ├── replay/
│   │   │   └── [tradeId]/page.tsx # Trade replay viewer
│   │   └── review/
│   │       └── page.tsx          # Weekly review dashboard
│   │
│   ├── components/
│   │   ├── chart/
│   │   │   ├── Chart.tsx         # Main chart wrapper
│   │   │   ├── CandleSeries.tsx  # Candlestick rendering
│   │   │   ├── IndicatorPane.tsx # Separate indicator pane
│   │   │   ├── indicators/       # Indicator overlays
│   │   │   │   ├── RSIIndicator.tsx
│   │   │   │   ├── EMAIndicator.tsx
│   │   │   │   ├── ATRIndicator.tsx
│   │   │   │   └── index.ts
│   │   │   └── primitives/       # Custom drawing primitives
│   │   │       ├── FVGPrimitive.ts
│   │   │       ├── SessionLevelPrimitive.ts
│   │   │       ├── SweepPrimitive.ts
│   │   │       ├── ZonePrimitive.ts
│   │   │       ├── SignalPrimitive.ts
│   │   │       └── index.ts
│   │   ├── trade/
│   │   │   ├── TradeLogger.tsx   # Entry form
│   │   │   ├── TradeCard.tsx     # Individual trade display
│   │   │   ├── TradeList.tsx     # Filterable trade list
│   │   │   └── TradeStats.tsx    # Performance metrics
│   │   ├── analysis/
│   │   │   ├── ClaudeChat.tsx    # Chat interface
│   │   │   ├── SetupAlert.tsx    # Setup notification
│   │   │   ├── AnalysisPanel.tsx # Side panel analysis
│   │   │   └── SetupChecklist.tsx # Strategy condition display
│   │   ├── strategy/
│   │   │   ├── StrategyEditor.tsx
│   │   │   ├── ConditionBuilder.tsx
│   │   │   └── BacktestResults.tsx
│   │   ├── replay/
│   │   │   ├── ReplayPlayer.tsx
│   │   │   ├── ReplayControls.tsx
│   │   │   └── AnnotationOverlay.tsx
│   │   └── ui/                   # Shared UI components
│   │       ├── Button.tsx
│   │       ├── Card.tsx
│   │       ├── Input.tsx
│   │       ├── Modal.tsx
│   │       └── ...
│   │
│   ├── lib/
│   │   ├── oanda/
│   │   │   ├── client.ts         # OANDA API client
│   │   │   ├── streaming.ts      # Price streaming handler
│   │   │   ├── types.ts          # OANDA type definitions
│   │   │   └── utils.ts          # Pair formatting, etc.
│   │   ├── indicators/
│   │   │   ├── rsi.ts
│   │   │   ├── ema.ts
│   │   │   ├── sma.ts
│   │   │   ├── atr.ts
│   │   │   ├── macd.ts
│   │   │   └── index.ts
│   │   ├── detection/
│   │   │   ├── fvg.ts            # FVG detection logic
│   │   │   ├── sweep.ts          # Sweep detection
│   │   │   ├── bos.ts            # Break of structure
│   │   │   ├── displacement.ts   # Displacement/velocity calc
│   │   │   ├── sessionLevels.ts  # Session high/low calc
│   │   │   └── htfLevels.ts      # HTF level calc
│   │   ├── strategy/
│   │   │   ├── evaluator.ts      # Strategy condition checker
│   │   │   ├── backtester.ts     # Backtest runner
│   │   │   ├── conditions.ts     # Condition type handlers
│   │   │   └── types.ts
│   │   ├── replay/
│   │   │   ├── generator.ts      # Replay generation
│   │   │   ├── player.ts         # Playback logic
│   │   │   └── types.ts
│   │   ├── ai/
│   │   │   ├── claude.ts         # Claude API wrapper
│   │   │   ├── openrouter.ts     # OpenRouter wrapper (optional)
│   │   │   ├── prompts.ts        # System prompts
│   │   │   └── types.ts
│   │   └── utils/
│   │       ├── time.ts           # Session time helpers
│   │       ├── pips.ts           # Pip calculations
│   │       ├── candles.ts        # Candle utilities
│   │       ├── screenshot.ts     # Chart screenshot capture
│   │       └── format.ts         # Number/date formatting
│   │
│   ├── hooks/
│   │   ├── useChart.ts           # Chart instance management
│   │   ├── useLiveCandles.ts     # Real-time candle subscription
│   │   ├── useIndicators.ts      # Indicator calculations
│   │   ├── useSessionLevels.ts   # Session level subscription
│   │   ├── useStrategy.ts        # Active strategy state
│   │   ├── useSetupDetection.ts  # Live setup scanning
│   │   ├── useClaude.ts          # Claude API interaction
│   │   └── useTradeLog.ts        # Trade CRUD operations
│   │
│   └── stores/
│       ├── chartStore.ts         # Chart state (Zustand)
│       ├── tradeStore.ts         # Active trade state
│       └── settingsStore.ts      # User preferences
│
├── public/
│   └── ...
│
├── package.json
├── convex.json
├── tailwind.config.js
├── tsconfig.json
├── next.config.js
└── .env.local                    # API keys
```

---

## Database Schema (Convex)

```typescript
// convex/schema.ts
import { defineSchema, defineTable } from "convex/server";
import { v } from "convex/values";

export default defineSchema({
  
  // ═══════════════════════════════════════════════════════════════
  // MARKET DATA
  // ═══════════════════════════════════════════════════════════════
  
  candles: defineTable({
    pair: v.string(),               // "EUR_USD"
    timeframe: v.string(),          // "M1", "M5", "M15", "H1", "H4", "D"
    timestamp: v.number(),          // Unix timestamp (ms)
    open: v.number(),
    high: v.number(),
    low: v.number(),
    close: v.number(),
    volume: v.number(),
    complete: v.boolean(),          // Is candle closed?
    
    // Velocity data (computed on candle close)
    timeToHighMs: v.optional(v.number()),
    timeToLowMs: v.optional(v.number()),
    highFormedFirst: v.optional(v.boolean()),
    bodyPercent: v.optional(v.number()),
    upperWickPercent: v.optional(v.number()),
    lowerWickPercent: v.optional(v.number()),
    rangePips: v.optional(v.number()),
    rangeVelocity: v.optional(v.number()),     // pips per second
    isDisplacement: v.optional(v.boolean()),
    displacementScore: v.optional(v.number()), // 0-100
  })
    .index("by_pair_tf", ["pair", "timeframe"])
    .index("by_pair_tf_time", ["pair", "timeframe", "timestamp"])
    .index("by_pair_tf_complete", ["pair", "timeframe", "complete"]),

  // ═══════════════════════════════════════════════════════════════
  // SESSION & HTF LEVELS
  // ═══════════════════════════════════════════════════════════════

  sessionLevels: defineTable({
    pair: v.string(),
    date: v.string(),               // "2026-01-15"
    
    // Asia session (00:00 - 08:00 GMT)
    asiaHigh: v.number(),
    asiaLow: v.number(),
    asiaOpen: v.number(),
    asiaClose: v.number(),
    asiaRangePips: v.number(),
    asiaTimeOfHigh: v.string(),
    asiaTimeOfLow: v.string(),
    
    // London session (08:00 - 16:00 GMT)
    londonHigh: v.number(),
    londonLow: v.number(),
    londonOpen: v.number(),
    londonClose: v.number(),
    londonRangePips: v.number(),
    londonSweptAsiaHigh: v.boolean(),
    londonSweptAsiaLow: v.boolean(),
    londonTimeOfHigh: v.string(),
    londonTimeOfLow: v.string(),
    
    // New York session (13:00 - 21:00 GMT)
    nyHigh: v.number(),
    nyLow: v.number(),
    nyOpen: v.number(),
    nyClose: v.number(),
    nyRangePips: v.number(),
    nySweptLondonHigh: v.boolean(),
    nySweptLondonLow: v.boolean(),
    nySweptAsiaHigh: v.boolean(),
    nySweptAsiaLow: v.boolean(),
    nyTimeOfHigh: v.string(),
    nyTimeOfLow: v.string(),
    
    // Daily
    dailyHigh: v.number(),
    dailyLow: v.number(),
    dailyOpen: v.number(),
    dailyClose: v.number(),
    dailyRangePips: v.number(),
    dailyTimeOfHigh: v.string(),
    dailyTimeOfLow: v.string(),
    highBeforeLow: v.boolean(),
    
    // Previous day reference
    previousDayHigh: v.number(),
    previousDayLow: v.number(),
    sweptPDH: v.boolean(),
    sweptPDL: v.boolean(),
  })
    .index("by_pair", ["pair"])
    .index("by_pair_date", ["pair", "date"]),

  htfLevels: defineTable({
    pair: v.string(),
    date: v.string(),               // Updated daily
    
    // Weekly
    weeklyHigh: v.number(),
    weeklyLow: v.number(),
    weeklyOpen: v.number(),
    weeklyClose: v.optional(v.number()),
    previousWeekHigh: v.number(),
    previousWeekLow: v.number(),
    
    // Monthly
    monthlyHigh: v.number(),
    monthlyLow: v.number(),
    monthlyOpen: v.number(),
    monthlyClose: v.optional(v.number()),
    previousMonthHigh: v.number(),
    previousMonthLow: v.number(),
    
    // Quarterly
    quarterlyHigh: v.number(),
    quarterlyLow: v.number(),
    quarterlyOpen: v.number(),
    previousQuarterHigh: v.number(),
    previousQuarterLow: v.number(),
    
    // Yearly
    yearlyHigh: v.number(),
    yearlyLow: v.number(),
    yearlyOpen: v.number(),
    previousYearHigh: v.number(),
    previousYearLow: v.number(),
  })
    .index("by_pair", ["pair"])
    .index("by_pair_date", ["pair", "date"]),

  // ═══════════════════════════════════════════════════════════════
  // PATTERN DETECTION
  // ═══════════════════════════════════════════════════════════════

  fvgs: defineTable({
    pair: v.string(),
    timeframe: v.string(),
    timestamp: v.number(),          // When FVG formed
    direction: v.union(v.literal("bullish"), v.literal("bearish")),
    
    // Gap boundaries
    gapHigh: v.number(),
    gapLow: v.number(),
    gapSizePips: v.number(),
    gapMidpoint: v.number(),
    
    // Formation characteristics
    displacementVelocity: v.number(),
    displacementBodyPercent: v.number(),
    formationVolume: v.optional(v.number()),
    
    // Context
    sessionFormedIn: v.string(),    // "asia", "london", "new_york"
    nearHTFLevel: v.boolean(),
    htfLevelName: v.optional(v.string()),
    
    // Fill tracking
    status: v.union(v.literal("unfilled"), v.literal("partial"), v.literal("filled")),
    fillPercentage: v.number(),
    timeToFillMs: v.optional(v.number()),
    candlesToFill: v.optional(v.number()),
    priceReactionAtFill: v.optional(v.string()),
    
    // Trade association
    tradedFromThis: v.boolean(),
    tradeId: v.optional(v.id("trades")),
    tradeResult: v.optional(v.string()),
  })
    .index("by_pair_tf", ["pair", "timeframe"])
    .index("by_pair_status", ["pair", "status"])
    .index("by_pair_tf_time", ["pair", "timeframe", "timestamp"]),

  sweeps: defineTable({
    pair: v.string(),
    timestamp: v.number(),
    
    levelSwept: v.string(),         // "asia_high", "pdl", "pwh", "equal_lows"
    levelPrice: v.number(),
    direction: v.union(v.literal("above"), v.literal("below")),
    
    // Sweep characteristics
    exceededByPips: v.number(),
    timeBeyondLevelMs: v.number(),
    candlesBeyondLevel: v.number(),
    sweepVelocity: v.number(),
    
    // Outcome
    immediateReversal: v.boolean(),
    reversalFollowed: v.boolean(),
    reversalSizePips: v.optional(v.number()),
    reversalDurationCandles: v.optional(v.number()),
    
    // Trade association
    tradedThisSweep: v.boolean(),
    tradeId: v.optional(v.id("trades")),
    tradeResult: v.optional(v.string()),
  })
    .index("by_pair", ["pair"])
    .index("by_pair_time", ["pair", "timestamp"])
    .index("by_pair_level", ["pair", "levelSwept"]),

  // ═══════════════════════════════════════════════════════════════
  // TRADES
  // ═══════════════════════════════════════════════════════════════

  trades: defineTable({
    pair: v.string(),
    direction: v.union(v.literal("long"), v.literal("short")),
    status: v.union(v.literal("pending"), v.literal("open"), v.literal("closed")),
    
    // Entry
    entryTimestamp: v.number(),
    entryPrice: v.number(),
    stopLoss: v.number(),
    takeProfit: v.number(),
    positionSize: v.optional(v.number()),
    
    // Exit
    exitTimestamp: v.optional(v.number()),
    exitPrice: v.optional(v.number()),
    exitReason: v.optional(v.union(
      v.literal("tp_hit"),
      v.literal("sl_hit"),
      v.literal("manual"),
      v.literal("trailing"),
      v.literal("breakeven")
    )),
    
    // Outcome
    outcome: v.optional(v.union(
      v.literal("win"),
      v.literal("loss"),
      v.literal("breakeven")
    )),
    rrAchieved: v.optional(v.number()),
    pnlPips: v.optional(v.number()),
    pnlPercent: v.optional(v.number()),
    durationMs: v.optional(v.number()),
    durationCandles: v.optional(v.number()),
    
    // ═══ HUMAN LAYER ═══
    screenshotEntry: v.optional(v.string()),    // Convex file ID
    screenshotExit: v.optional(v.string()),
    thoughtsPreEntry: v.optional(v.string()),
    thoughtsDuring: v.optional(v.string()),
    thoughtsPostTrade: v.optional(v.string()),
    voiceNotes: v.optional(v.array(v.string())),
    tags: v.optional(v.array(v.string())),
    
    // ═══ MACHINE LAYER ═══
    technicalSnapshot: v.object({
      // Candles at entry (last N candles per timeframe)
      candles: v.object({
        m5: v.optional(v.array(v.any())),
        m15: v.array(v.any()),
        h1: v.array(v.any()),
        h4: v.array(v.any()),
        d1: v.optional(v.array(v.any())),
      }),
      // Indicator values at entry
      indicators: v.object({
        rsi14: v.optional(v.number()),
        ema21: v.optional(v.number()),
        ema50: v.optional(v.number()),
        ema200: v.optional(v.number()),
        atr14: v.optional(v.number()),
        macdLine: v.optional(v.number()),
        macdSignal: v.optional(v.number()),
        macdHist: v.optional(v.number()),
      }),
      // Levels at entry
      sessionLevels: v.any(),
      htfLevels: v.any(),
      // Nearby patterns
      nearbyFVGs: v.array(v.any()),
      recentSweeps: v.array(v.any()),
    }),
    
    // ═══ CONTEXT ═══
    session: v.string(),            // "asia", "london", "new_york", "overlap"
    dayOfWeek: v.string(),
    
    // Behavior tracking
    minutesSinceLastTrade: v.optional(v.number()),
    lastTradeResult: v.optional(v.string()),
    tradesTodayCount: v.number(),
    dailyPnlAtEntry: v.optional(v.number()),
    weeklyPnlAtEntry: v.optional(v.number()),
    isPotentialRevengeTrade: v.optional(v.boolean()),
    
    // News context
    nearestNewsEvent: v.optional(v.string()),
    minutesFromNews: v.optional(v.number()),
    newsWasBefore: v.optional(v.boolean()),
    newsOccurredDuringTrade: v.optional(v.boolean()),
    
    // DXY context
    dxyAtEntry: v.optional(v.number()),
    dxyTrend1h: v.optional(v.string()),
    dxyTrend4h: v.optional(v.string()),
    dxyTrendDaily: v.optional(v.string()),
    dxyDivergent: v.optional(v.boolean()),
    
    // Strategy reference
    strategyId: v.optional(v.id("strategies")),
    strategyConditionsMet: v.optional(v.array(v.string())),
    strategyConditionsMissing: v.optional(v.array(v.string())),
    strategyScore: v.optional(v.number()),
    
    // ═══ AI LAYER ═══
    claudeAnalysisAtEntry: v.optional(v.string()),
    claudePatternMatches: v.optional(v.array(v.object({
      patternName: v.string(),
      similarityScore: v.number(),
      historicalWinRate: v.number(),
      sampleSize: v.number(),
    }))),
    claudePostTradeReview: v.optional(v.string()),
  })
    .index("by_pair", ["pair"])
    .index("by_status", ["status"])
    .index("by_outcome", ["outcome"])
    .index("by_entry_time", ["entryTimestamp"])
    .index("by_strategy", ["strategyId"])
    .index("by_pair_status", ["pair", "status"]),

  // ═══════════════════════════════════════════════════════════════
  // STRATEGIES
  // ═══════════════════════════════════════════════════════════════

  strategies: defineTable({
    name: v.string(),
    description: v.optional(v.string()),
    status: v.union(v.literal("active"), v.literal("shadow"), v.literal("archived")),
    
    // Strategy definition
    conditions: v.array(v.object({
      id: v.string(),
      type: v.string(),             // "session_sweep", "fvg_present", "indicator", etc.
      params: v.any(),              // Type-specific parameters
      weight: v.number(),           // 0-1
      required: v.boolean(),
    })),
    minimumScore: v.number(),       // 0-1, threshold to trigger
    
    // Risk rules
    defaultStopLoss: v.optional(v.object({
      type: v.string(),             // "pips", "atr_multiple", "structure"
      value: v.number(),
    })),
    defaultTakeProfit: v.optional(v.object({
      type: v.string(),             // "pips", "rr_multiple", "structure"
      value: v.number(),
    })),
    
    // Performance tracking (updated periodically)
    stats: v.optional(v.object({
      totalTrades: v.number(),
      wins: v.number(),
      losses: v.number(),
      breakeven: v.number(),
      winRate: v.number(),
      averageRR: v.number(),
      profitFactor: v.number(),
      maxDrawdown: v.number(),
      lastUpdated: v.number(),
    })),
    
    createdAt: v.number(),
    updatedAt: v.number(),
  })
    .index("by_status", ["status"]),

  // ═══════════════════════════════════════════════════════════════
  // BACKTESTS
  // ═══════════════════════════════════════════════════════════════

  backtests: defineTable({
    strategyId: v.id("strategies"),
    strategyName: v.string(),
    pair: v.string(),
    timeframe: v.string(),
    dateFrom: v.string(),
    dateTo: v.string(),
    
    // Results
    totalTrades: v.number(),
    wins: v.number(),
    losses: v.number(),
    breakeven: v.number(),
    winRate: v.number(),
    profitFactor: v.number(),
    averageRR: v.number(),
    maxDrawdown: v.number(),
    maxConsecutiveLosses: v.number(),
    averageHoldTimeMs: v.number(),
    tradesPerWeek: v.number(),
    
    // By session breakdown
    statsBySession: v.optional(v.object({
      asia: v.any(),
      london: v.any(),
      newYork: v.any(),
    })),
    
    // By day breakdown
    statsByDay: v.optional(v.object({
      monday: v.any(),
      tuesday: v.any(),
      wednesday: v.any(),
      thursday: v.any(),
      friday: v.any(),
    })),
    
    // Individual trades
    trades: v.array(v.object({
      entryTimestamp: v.number(),
      exitTimestamp: v.number(),
      direction: v.string(),
      entryPrice: v.number(),
      exitPrice: v.number(),
      stopLoss: v.number(),
      takeProfit: v.number(),
      outcome: v.string(),
      rrAchieved: v.number(),
      pnlPips: v.number(),
      conditionsMet: v.array(v.string()),
    })),
    
    createdAt: v.number(),
  })
    .index("by_strategy", ["strategyId"])
    .index("by_pair", ["pair"])
    .index("by_created", ["createdAt"]),

  // ═══════════════════════════════════════════════════════════════
  // NEWS EVENTS
  // ═══════════════════════════════════════════════════════════════

  newsEvents: defineTable({
    timestamp: v.number(),
    eventName: v.string(),          // "Non-Farm Payrolls", "FOMC", "CPI"
    currencyAffected: v.string(),   // "USD", "EUR", "GBP"
    importance: v.union(v.literal("low"), v.literal("medium"), v.literal("high")),
    
    // Data
    forecast: v.optional(v.string()),
    actual: v.optional(v.string()),
    previous: v.optional(v.string()),
    deviation: v.optional(v.number()),
    
    // Market reaction (filled after event)
    initialSpikeDirection: v.optional(v.string()),
    initialSpikePips: v.optional(v.number()),
    initialSpikeVelocity: v.optional(v.number()),
    timeToPeakMs: v.optional(v.number()),
    reversedInitialMove: v.optional(v.boolean()),
    timeToReversalMs: v.optional(v.number()),
    reversalVelocity: v.optional(v.number()),
    settledDirection: v.optional(v.string()),
    range1hAfter: v.optional(v.number()),
  })
    .index("by_time", ["timestamp"])
    .index("by_currency", ["currencyAffected"])
    .index("by_importance", ["importance"]),

  // ═══════════════════════════════════════════════════════════════
  // AI CONVERSATIONS
  // ═══════════════════════════════════════════════════════════════

  claudeConversations: defineTable({
    context: v.string(),            // "trade_analysis", "setup_scan", "backtest_review", "general"
    tradeId: v.optional(v.id("trades")),
    strategyId: v.optional(v.id("strategies")),
    
    messages: v.array(v.object({
      role: v.union(v.literal("user"), v.literal("assistant")),
      content: v.string(),
      timestamp: v.number(),
    })),
    
    // Context that was provided
    contextData: v.optional(v.any()),
    
    createdAt: v.number(),
    updatedAt: v.number(),
  })
    .index("by_trade", ["tradeId"])
    .index("by_strategy", ["strategyId"])
    .index("by_context", ["context"]),

  // ═══════════════════════════════════════════════════════════════
  // USER SETTINGS
  // ═══════════════════════════════════════════════════════════════

  userSettings: defineTable({
    userId: v.string(),
    
    // Trading preferences
    defaultPairs: v.array(v.string()),
    defaultTimeframe: v.string(),
    timezone: v.string(),
    
    // Session times (customizable)
    sessionTimes: v.object({
      asiaStart: v.string(),        // "00:00"
      asiaEnd: v.string(),
      londonStart: v.string(),
      londonEnd: v.string(),
      nyStart: v.string(),
      nyEnd: v.string(),
    }),
    
    // Display preferences
    chartTheme: v.string(),
    showClaudeOverlays: v.boolean(),
    
    // Notification preferences
    setupAlerts: v.boolean(),
    alertSound: v.boolean(),
    
    // API keys (encrypted in production)
    oandaAccountId: v.optional(v.string()),
    
    updatedAt: v.number(),
  })
    .index("by_user", ["userId"]),
});
```

---

## Key Dependencies

```json
{
  "name": "trading-system",
  "version": "0.1.0",
  "private": true,
  "scripts": {
    "dev": "next dev",
    "build": "next build",
    "start": "next start",
    "lint": "next lint",
    "convex": "convex dev"
  },
  "dependencies": {
    "react": "^18.2.0",
    "react-dom": "^18.2.0",
    "next": "^14.1.0",
    
    "convex": "^1.10.0",
    
    "lightweight-charts": "^5.0.0",
    
    "@anthropic-ai/sdk": "^0.20.0",
    
    "tailwindcss": "^3.4.0",
    "clsx": "^2.1.0",
    "tailwind-merge": "^2.2.0",
    
    "zustand": "^4.5.0",
    
    "date-fns": "^3.3.0",
    "date-fns-tz": "^2.0.0",
    
    "html2canvas": "^1.4.1",
    
    "lucide-react": "^0.330.0",
    
    "zod": "^3.22.0"
  },
  "devDependencies": {
    "typescript": "^5.3.0",
    "@types/react": "^18.2.0",
    "@types/react-dom": "^18.2.0",
    "@types/node": "^20.11.0",
    "eslint": "^8.56.0",
    "eslint-config-next": "^14.1.0",
    "autoprefixer": "^10.4.17",
    "postcss": "^8.4.35"
  }
}
```

---

## Environment Variables

```bash
# .env.local

# ═══════════════════════════════════════════
# OANDA API
# ═══════════════════════════════════════════
# Get from: https://www.oanda.com/demo-account/
OANDA_API_KEY=your_oanda_api_key_here
OANDA_ACCOUNT_ID=xxx-xxx-xxxxxxx-xxx

# Demo vs Live (use demo for development)
OANDA_API_URL=https://api-fxpractice.oanda.com
# For live: https://api-fxtrade.oanda.com

OANDA_STREAM_URL=https://stream-fxpractice.oanda.com
# For live: https://stream-fxtrade.oanda.com

# ═══════════════════════════════════════════
# ANTHROPIC (Claude)
# ═══════════════════════════════════════════
# Get from: https://console.anthropic.com/
ANTHROPIC_API_KEY=sk-ant-xxxxxxxxxxxxx

# ═══════════════════════════════════════════
# OPENROUTER (Optional - for model flexibility)
# ═══════════════════════════════════════════
# Get from: https://openrouter.ai/
OPENROUTER_API_KEY=sk-or-xxxxxxxxxxxxx

# ═══════════════════════════════════════════
# CONVEX
# ═══════════════════════════════════════════
# Auto-configured by `npx convex dev`
CONVEX_DEPLOYMENT=your-deployment-name
NEXT_PUBLIC_CONVEX_URL=https://your-deployment.convex.cloud
```

---

## Core Implementation Examples

### OANDA Candle Fetching

```typescript
// convex/oanda.ts
"use node";

import { action } from "./_generated/server";
import { v } from "convex/values";
import { internal } from "./_generated/api";

export const fetchCandles = action({
  args: {
    pair: v.string(),
    timeframe: v.string(),
    count: v.optional(v.number()),
    from: v.optional(v.string()),
    to: v.optional(v.string()),
  },
  handler: async (ctx, args) => {
    const params = new URLSearchParams({
      granularity: args.timeframe,
      count: String(args.count || 500),
    });
    
    if (args.from) params.set("from", args.from);
    if (args.to) params.set("to", args.to);

    const response = await fetch(
      `${process.env.OANDA_API_URL}/v3/instruments/${args.pair}/candles?${params}`,
      {
        headers: {
          Authorization: `Bearer ${process.env.OANDA_API_KEY}`,
          "Content-Type": "application/json",
        },
      }
    );

    if (!response.ok) {
      throw new Error(`OANDA API error: ${response.status}`);
    }

    const data = await response.json();
    
    // Transform and store candles
    const candles = data.candles.map((c: any) => ({
      pair: args.pair,
      timeframe: args.timeframe,
      timestamp: new Date(c.time).getTime(),
      open: parseFloat(c.mid.o),
      high: parseFloat(c.mid.h),
      low: parseFloat(c.mid.l),
      close: parseFloat(c.mid.c),
      volume: c.volume,
      complete: c.complete,
    }));

    // Store in database
    for (const candle of candles) {
      await ctx.runMutation(internal.candles.upsertCandle, candle);
    }

    return candles;
  },
});
```

### Claude Analysis Integration

```typescript
// convex/analysis.ts
"use node";

import Anthropic from "@anthropic-ai/sdk";
import { action } from "./_generated/server";
import { v } from "convex/values";

const anthropic = new Anthropic({
  apiKey: process.env.ANTHROPIC_API_KEY,
});

export const analyzeSetup = action({
  args: {
    pair: v.string(),
    candles: v.any(),
    indicators: v.any(),
    sessionLevels: v.any(),
    htfLevels: v.any(),
    fvgs: v.any(),
    recentSweeps: v.any(),
    strategy: v.any(),
    tradeHistory: v.optional(v.any()),
    question: v.optional(v.string()),
  },
  handler: async (ctx, args) => {
    const systemPrompt = `You are a forex trading analyst assistant. You analyze chart setups with precision and reference specific data points.

You have access to:
- Current candle data across multiple timeframes
- Indicator values (RSI, EMAs, ATR, etc.)
- Session levels (Asia, London, NY highs/lows)
- Higher timeframe levels (weekly, monthly, quarterly)
- Detected Fair Value Gaps with velocity data
- Recent liquidity sweep events
- The user's trading strategy rules
- Historical trade data (when provided)

Your role:
1. Evaluate if current conditions match the strategy criteria
2. Identify confluence or conflicting signals
3. Reference specific prices, times, and values
4. Compare to historical similar setups when data is available
5. Be direct and specific — avoid vague statements

You do NOT predict price direction. You assess probability based on defined criteria and historical data.`;

    const userContent = `
## Pair: ${args.pair}

## Recent Candles (15m, last 20):
${JSON.stringify(args.candles?.m15?.slice(-20), null, 2)}

## Current Indicators:
${JSON.stringify(args.indicators, null, 2)}

## Today's Session Levels:
${JSON.stringify(args.sessionLevels, null, 2)}

## HTF Levels:
${JSON.stringify(args.htfLevels, null, 2)}

## Active FVGs:
${JSON.stringify(args.fvgs, null, 2)}

## Recent Sweeps (last 24h):
${JSON.stringify(args.recentSweeps, null, 2)}

## Strategy Rules:
${JSON.stringify(args.strategy, null, 2)}

${args.tradeHistory ? `## Historical Similar Trades:\n${JSON.stringify(args.tradeHistory, null, 2)}` : ""}

## Question:
${args.question || "Analyze this setup. Does it meet the strategy criteria? What is the key confluence or conflict?"}
`;

    const message = await anthropic.messages.create({
      model: "claude-sonnet-4-20250514",
      max_tokens: 1500,
      system: systemPrompt,
      messages: [{ role: "user", content: userContent }],
    });

    return {
      analysis: message.content[0].type === "text" ? message.content[0].text : "",
      usage: message.usage,
    };
  },
});
```

### Lightweight Charts Setup

```typescript
// src/components/chart/Chart.tsx
"use client";

import { useEffect, useRef } from "react";
import { createChart, IChartApi, ISeriesApi, CandlestickSeries } from "lightweight-charts";
import { useQuery } from "convex/react";
import { api } from "@/convex/_generated/api";

interface ChartProps {
  pair: string;
  timeframe: string;
}

export function Chart({ pair, timeframe }: ChartProps) {
  const containerRef = useRef<HTMLDivElement>(null);
  const chartRef = useRef<IChartApi | null>(null);
  const seriesRef = useRef<ISeriesApi<"Candlestick"> | null>(null);

  // Subscribe to live candles
  const candles = useQuery(api.candles.getCandles, { pair, timeframe, limit: 500 });

  // Initialize chart
  useEffect(() => {
    if (!containerRef.current) return;

    const chart = createChart(containerRef.current, {
      layout: {
        background: { type: "solid", color: "#0a0a0a" },
        textColor: "#d1d5db",
      },
      grid: {
        vertLines: { color: "#1f2937" },
        horzLines: { color: "#1f2937" },
      },
      crosshair: {
        mode: 1,
      },
      rightPriceScale: {
        borderColor: "#374151",
      },
      timeScale: {
        borderColor: "#374151",
        timeVisible: true,
      },
    });

    const series = chart.addSeries(CandlestickSeries, {
      upColor: "#22c55e",
      downColor: "#ef4444",
      borderUpColor: "#22c55e",
      borderDownColor: "#ef4444",
      wickUpColor: "#22c55e",
      wickDownColor: "#ef4444",
    });

    chartRef.current = chart;
    seriesRef.current = series;

    // Cleanup
    return () => {
      chart.remove();
    };
  }, []);

  // Update data when candles change
  useEffect(() => {
    if (!seriesRef.current || !candles) return;

    const formattedData = candles.map((c) => ({
      time: (c.timestamp / 1000) as any, // Lightweight Charts expects seconds
      open: c.open,
      high: c.high,
      low: c.low,
      close: c.close,
    }));

    seriesRef.current.setData(formattedData);
  }, [candles]);

  return <div ref={containerRef} className="w-full h-full" />;
}
```

---

## Build Phases

### Phase 1: Foundation ✅
- [ ] Initialize Next.js project with TypeScript
- [ ] Set up Convex project and schema
- [ ] Configure Tailwind CSS
- [ ] Create basic project structure
- [ ] Set up environment variables

### Phase 2: Data Pipeline
- [ ] OANDA API client implementation
- [ ] Fetch and store historical candles
- [ ] Basic candle query functions
- [ ] Implement candle upsert (avoid duplicates)

### Phase 3: Live Chart
- [ ] Lightweight Charts integration
- [ ] Candlestick rendering
- [ ] Real-time candle updates via Convex subscription
- [ ] Timeframe switching
- [ ] Pair switching

### Phase 4: Indicators & Detection
- [ ] Indicator calculations (RSI, EMA, ATR)
- [ ] Session level detection and storage
- [ ] HTF level calculations
- [ ] FVG detection algorithm
- [ ] Sweep detection algorithm
- [ ] Displacement/velocity calculations

### Phase 5: Chart Primitives
- [ ] Session level drawing primitive
- [ ] FVG zone primitive
- [ ] Sweep marker primitive
- [ ] Signal marker primitive
- [ ] HTF level primitive

### Phase 6: Trade Logging
- [ ] Trade entry form UI
- [ ] Screenshot capture on entry
- [ ] Technical snapshot collection
- [ ] Trade outcome tracking
- [ ] Trade list view with filters

### Phase 7: Claude Integration
- [ ] Basic Claude API connection
- [ ] Setup analysis endpoint
- [ ] Chat interface component
- [ ] Pattern matching query
- [ ] Historical trade comparison

### Phase 8: Strategy System
- [ ] Strategy JSON schema definition
- [ ] Strategy editor UI
- [ ] Condition evaluator engine
- [ ] Setup alert system
- [ ] Partial match display

### Phase 9: Backtesting
- [ ] Backtest runner engine
- [ ] Results storage and display
- [ ] Strategy comparison view
- [ ] Performance breakdown (by session, day)

### Phase 10: Review & Replay
- [ ] Trade replay generator
- [ ] Replay player UI
- [ ] Annotation overlay system
- [ ] Weekly review dashboard
- [ ] Performance analytics charts

### Phase 11: Advanced (Future)
- [ ] Strategy Lab (shadow strategies)
- [ ] Market regime detection
- [ ] Multi-strategy comparison
- [ ] Voice note integration
- [ ] Mobile responsive / PWA

---

*Document Version: 1.0 — Technical Specification*
*Last Updated: January 2026*
