// This Pine Script® code is subject to the terms of the Mozilla Public License 2.0 at https://mozilla.org/MPL/2.0/
// © Essa / Based on caspersmcwisdom's First Candle Rule

//@version=6
indicator("First Candle Rule (FCR) v3", overlay=true, max_boxes_count=100, max_lines_count=100, max_labels_count=100)

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//// SETTINGS
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

sessionStart = input.session("0930-0935", "FCR Session (Market Open)", group="Setup")
sessionTimezone = input.string("America/New_York", "Timezone", options=["America/New_York", "America/Chicago", "America/Los_Angeles", "Europe/London", "UTC"], group="Setup")

showFCRBox = input.bool(true, "Show FCR Candle Box", group="Visuals")
showFCRLines = input.bool(true, "Show FCR High/Low Lines", group="Visuals")
showFVG = input.bool(true, "Show Fair Value Gaps", group="Visuals")
showSignals = input.bool(true, "Show Entry Signals", group="Visuals")
showPosition = input.bool(true, "Show TP/SL Zones", group="Visuals")
showHistoryTable = input.bool(true, "Show History Table", group="Visuals")
showStatusTable = input.bool(true, "Show Status Table", group="Visuals")

rrRatio = input.float(3.0, "Risk:Reward Ratio", minval=1.0, maxval=10.0, step=0.5, group="Strategy")

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//// HISTORY TRACKING ARRAYS
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

var int[] histDirection = array.new<int>()
var float[] histEntry = array.new<float>()
var float[] histTP = array.new<float>()
var float[] histSL = array.new<float>()
var string[] histResult = array.new<string>()
var float[] histPnL = array.new<float>()
var int[] histEntryBar = array.new<int>()
var int[] histExitBar = array.new<int>()

const int MAX_HISTORY = 10

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//// FCR DETECTION
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

inFCRSession = not na(time(timeframe.period, sessionStart, sessionTimezone))
fcrSessionStart = inFCRSession and not inFCRSession[1]
fcrSessionEnd = not inFCRSession and inFCRSession[1]

var float fcrHigh = na
var float fcrLow = na
var int fcrStartBar = na
var int fcrEndBar = na
var bool fcrEstablished = false

newTradingDay = dayofweek != dayofweek[1]

// Reset everything on new day
if newTradingDay
    fcrHigh := na
    fcrLow := na
    fcrEstablished := false

if inFCRSession
    if fcrSessionStart
        fcrHigh := high
        fcrLow := low
        fcrStartBar := bar_index
    else
        fcrHigh := math.max(fcrHigh, high)
        fcrLow := math.min(fcrLow, low)

if fcrSessionEnd
    fcrEndBar := bar_index
    fcrEstablished := true

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//// FCR VISUALS
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

if fcrSessionEnd and showFCRBox
    box.new(fcrStartBar, fcrHigh, bar_index, fcrLow, bgcolor=color.new(color.blue, 85), border_color=color.new(color.blue, 30), border_width=1)
    label.new(fcrStartBar, fcrHigh, "FCR", style=label.style_label_down, color=color.new(color.blue, 80), textcolor=color.white, size=size.small)

var line fcrHighLine = na
var line fcrLowLine = na

if fcrSessionEnd and showFCRLines
    fcrHighLine := line.new(bar_index, fcrHigh, bar_index + 200, fcrHigh, color=color.new(color.blue, 30), style=line.style_solid, width=1)
    fcrLowLine := line.new(bar_index, fcrLow, bar_index + 200, fcrLow, color=color.new(color.blue, 30), style=line.style_solid, width=1)

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//// BREAKOUT DETECTION
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

var int breakoutDirection = 0  // 0 = none, 1 = bullish, -1 = bearish
var bool breakoutOccurred = false
var int breakoutBar = na

if fcrEstablished and not breakoutOccurred and not na(fcrHigh) and not na(fcrLow)
    // Bullish breakout: candle CLOSES above FCR high
    if close > fcrHigh and close[1] <= fcrHigh
        breakoutDirection := 1
        breakoutOccurred := true
        breakoutBar := bar_index
    // Bearish breakout: candle CLOSES below FCR low
    else if close < fcrLow and close[1] >= fcrLow
        breakoutDirection := -1
        breakoutOccurred := true
        breakoutBar := bar_index

if newTradingDay
    breakoutDirection := 0
    breakoutOccurred := false
    breakoutBar := na

bullishBreakout = breakoutOccurred and breakoutDirection == 1 and bar_index == breakoutBar
bearishBreakout = breakoutOccurred and breakoutDirection == -1 and bar_index == breakoutBar

plotshape(bullishBreakout and showSignals, title="Bullish Breakout", style=shape.triangleup, location=location.belowbar, color=color.green, size=size.small, text="Break")
plotshape(bearishBreakout and showSignals, title="Bearish Breakout", style=shape.triangledown, location=location.abovebar, color=color.red, size=size.small, text="Break")

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//// FAIR VALUE GAP DETECTION
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

// Bullish FVG: Candle C's low > Candle A's high (gap up)
// We check on candle C, looking back at A (2 bars ago)
bullishFVGPresent = low > high[2]
bullishFVGTop = low          // Top of gap = Candle C's low
bullishFVGBottom = high[2]   // Bottom of gap = Candle A's high

// Bearish FVG: Candle C's high < Candle A's low (gap down)
bearishFVGPresent = high < low[2]
bearishFVGTop = low[2]       // Top of gap = Candle A's low
bearishFVGBottom = high      // Bottom of gap = Candle C's high

var box fvgBox = na
var float fvgTop = na
var float fvgBottom = na
var bool fvgEstablished = false
var int fvgBar = na

// Detect first FVG after breakout (within 20 bars)
if breakoutOccurred and not fvgEstablished and bar_index <= breakoutBar + 20
    if breakoutDirection == 1 and bullishFVGPresent
        fvgTop := bullishFVGTop
        fvgBottom := bullishFVGBottom
        fvgEstablished := true
        fvgBar := bar_index
        if showFVG
            fvgBox := box.new(bar_index - 2, fvgTop, bar_index, fvgBottom, bgcolor=color.new(color.gray, 75), border_color=color.gray, border_width=1, text="FVG", text_color=color.white, text_size=size.small)
    
    if breakoutDirection == -1 and bearishFVGPresent
        fvgTop := bearishFVGTop
        fvgBottom := bearishFVGBottom
        fvgEstablished := true
        fvgBar := bar_index
        if showFVG
            fvgBox := box.new(bar_index - 2, fvgTop, bar_index, fvgBottom, bgcolor=color.new(color.gray, 75), border_color=color.gray, border_width=1, text="FVG", text_color=color.white, text_size=size.small)

if newTradingDay
    fvgTop := na
    fvgBottom := na
    fvgEstablished := false
    fvgBar := na

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//// RETEST DETECTION
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

var bool retestOccurred = false
var float retestExtreme = na  // Deepest point of retest
var int retestStartBar = na
var bool inRetestZone = false

// Check if current candle enters FVG zone
candleEntersFVGBullish = fvgEstablished and breakoutDirection == 1 and low <= fvgTop and high >= fvgBottom
candleEntersFVGBearish = fvgEstablished and breakoutDirection == -1 and high >= fvgBottom and low <= fvgTop

if fvgEstablished and not retestOccurred
    // Bullish: price pulls back, candle enters FVG zone
    if breakoutDirection == 1 and candleEntersFVGBullish
        retestOccurred := true
        retestExtreme := low
        retestStartBar := bar_index
        inRetestZone := true
    
    // Bearish: price pulls back, candle enters FVG zone
    if breakoutDirection == -1 and candleEntersFVGBearish
        retestOccurred := true
        retestExtreme := high
        retestStartBar := bar_index
        inRetestZone := true

// Update retest extreme while still near FVG (within 15 bars of retest start)
if retestOccurred and bar_index <= retestStartBar + 15
    if breakoutDirection == 1 and candleEntersFVGBullish
        retestExtreme := math.min(retestExtreme, low)
        inRetestZone := true
    else if breakoutDirection == 1
        inRetestZone := false
        
    if breakoutDirection == -1 and candleEntersFVGBearish
        retestExtreme := math.max(retestExtreme, high)
        inRetestZone := true
    else if breakoutDirection == -1
        inRetestZone := false

if newTradingDay
    retestOccurred := false
    retestExtreme := na
    retestStartBar := na
    inRetestZone := false

retestSignal = retestOccurred and bar_index == retestStartBar
plotshape(retestSignal and breakoutDirection == 1 and showSignals, title="Bullish Retest", style=shape.circle, location=location.belowbar, color=color.orange, size=size.tiny, text="Retest")
plotshape(retestSignal and breakoutDirection == -1 and showSignals, title="Bearish Retest", style=shape.circle, location=location.abovebar, color=color.orange, size=size.tiny, text="Retest")

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//// ENGULFING DETECTION AT FVG ZONE
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

// Bullish engulfing: current closes up and body covers previous body
bullishEngulfing = close > open and close > open[1] and open <= close[1]

// Bearish engulfing: current closes down and body covers previous body
bearishEngulfing = close < open and close < open[1] and open >= close[1]

// Check if engulfing candle is AT the FVG zone
// For bullish: the candle's body should touch/overlap the FVG zone
engulfingAtFVGBullish = bullishEngulfing and fvgEstablished and breakoutDirection == 1 and (math.min(open, close) <= fvgTop) and (math.max(open, close) >= fvgBottom)

// For bearish: the candle's body should touch/overlap the FVG zone  
engulfingAtFVGBearish = bearishEngulfing and fvgEstablished and breakoutDirection == -1 and (math.max(open, close) >= fvgBottom) and (math.min(open, close) <= fvgTop)

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//// ENTRY LOGIC
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

var bool tradeOpen = false
var bool entryTriggered = false
var float entryPrice = na
var float stopLoss = na
var float takeProfit = na
var int entryBar = na
var int entryDirection = 0

var box tpBox = na
var box slBox = na
var line entryLine = na

// Entry conditions
validBullishEntry = retestOccurred and not entryTriggered and not tradeOpen and engulfingAtFVGBullish and bar_index >= retestStartBar and bar_index <= retestStartBar + 15

validBearishEntry = retestOccurred and not entryTriggered and not tradeOpen and engulfingAtFVGBearish and bar_index >= retestStartBar and bar_index <= retestStartBar + 15

if validBullishEntry
    entryTriggered := true
    tradeOpen := true
    entryPrice := close
    stopLoss := retestExtreme - syminfo.mintick
    float risk = entryPrice - stopLoss
    takeProfit := entryPrice + (rrRatio * risk)
    entryBar := bar_index
    entryDirection := 1
    
    // Store in history
    array.push(histDirection, 1)
    array.push(histEntry, entryPrice)
    array.push(histTP, takeProfit)
    array.push(histSL, stopLoss)
    array.push(histResult, "OPEN")
    array.push(histPnL, 0.0)
    array.push(histEntryBar, bar_index)
    array.push(histExitBar, 0)

if validBearishEntry
    entryTriggered := true
    tradeOpen := true
    entryPrice := close
    stopLoss := retestExtreme + syminfo.mintick
    float risk = stopLoss - entryPrice
    takeProfit := entryPrice - (rrRatio * risk)
    entryBar := bar_index
    entryDirection := -1
    
    // Store in history
    array.push(histDirection, -1)
    array.push(histEntry, entryPrice)
    array.push(histTP, takeProfit)
    array.push(histSL, stopLoss)
    array.push(histResult, "OPEN")
    array.push(histPnL, 0.0)
    array.push(histEntryBar, bar_index)
    array.push(histExitBar, 0)

// Draw TP/SL boxes on entry
entrySignal = (validBullishEntry or validBearishEntry)

if entrySignal and showPosition
    entryLine := line.new(bar_index, entryPrice, bar_index + 1, entryPrice, color=color.white, style=line.style_dashed, width=1)
    
    if entryDirection == 1
        tpBox := box.new(bar_index, takeProfit, bar_index + 1, entryPrice, bgcolor=color.new(color.green, 85), border_color=color.green, border_width=1)
        slBox := box.new(bar_index, entryPrice, bar_index + 1, stopLoss, bgcolor=color.new(color.red, 85), border_color=color.red, border_width=1)
    else
        tpBox := box.new(bar_index, entryPrice, bar_index + 1, takeProfit, bgcolor=color.new(color.green, 85), border_color=color.green, border_width=1)
        slBox := box.new(bar_index, stopLoss, bar_index + 1, entryPrice, bgcolor=color.new(color.red, 85), border_color=color.red, border_width=1)

plotshape(entrySignal and entryDirection == 1 and showSignals, title="Buy Entry", style=shape.triangleup, location=location.belowbar, color=color.lime, size=size.normal, text="Entry")
plotshape(entrySignal and entryDirection == -1 and showSignals, title="Sell Entry", style=shape.triangledown, location=location.abovebar, color=color.red, size=size.normal, text="Entry")

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//// TRADE OUTCOME DETECTION (WITH SAME-BAR LOGIC)
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

var bool tpHit = false
var bool slHit = false
var int exitBar = na
var float exitPrice = na

// Extend boxes while trade is open
if tradeOpen and not na(tpBox) and not na(slBox) and not na(entryLine)
    box.set_right(tpBox, bar_index + 1)
    box.set_right(slBox, bar_index + 1)
    line.set_x2(entryLine, bar_index + 1)

// Extend FVG box while trade is open
if tradeOpen and not na(fvgBox)
    box.set_right(fvgBox, bar_index + 1)

// Check for TP/SL hit with same-bar priority logic
if tradeOpen and not tpHit and not slHit
    bool tpTouched = false
    bool slTouched = false
    
    if entryDirection == 1  // Long trade
        tpTouched := high >= takeProfit
        slTouched := low <= stopLoss
    else  // Short trade
        tpTouched := low <= takeProfit
        slTouched := high >= stopLoss
    
    // Same-bar priority: use candle direction to infer which was hit first
    if tpTouched and slTouched
        // Both levels hit on same candle - infer order from candle direction
        if entryDirection == 1  // Long trade
            if close > open  // Bullish candle: went down first (SL), then up (TP)
                // Likely SL hit first, but since it recovered, consider it SL
                slHit := true
                exitBar := bar_index
                exitPrice := stopLoss
            else  // Bearish candle: went up first (TP), then down
                // Likely TP hit first
                tpHit := true
                exitBar := bar_index
                exitPrice := takeProfit
        else  // Short trade
            if close < open  // Bearish candle: went up first (SL), then down (TP)
                slHit := true
                exitBar := bar_index
                exitPrice := stopLoss
            else  // Bullish candle: went down first (TP), then up
                tpHit := true
                exitBar := bar_index
                exitPrice := takeProfit
    else if tpTouched
        tpHit := true
        exitBar := bar_index
        exitPrice := takeProfit
    else if slTouched
        slHit := true
        exitBar := bar_index
        exitPrice := stopLoss

// Handle trade close
if (tpHit or slHit) and tradeOpen
    tradeOpen := false
    
    // Stop extending boxes - set final right edge
    if not na(tpBox)
        box.set_right(tpBox, bar_index)
    if not na(slBox)
        box.set_right(slBox, bar_index)
    if not na(entryLine)
        line.set_x2(entryLine, bar_index)
    if not na(fvgBox)
        box.set_right(fvgBox, bar_index)
    
    // Update last history entry
    int lastIdx = array.size(histResult) - 1
    if lastIdx >= 0
        float pnl = 0.0
        if tpHit
            array.set(histResult, lastIdx, "TP")
            if entryDirection == 1
                pnl := takeProfit - entryPrice
            else
                pnl := entryPrice - takeProfit
        else
            array.set(histResult, lastIdx, "SL")
            if entryDirection == 1
                pnl := stopLoss - entryPrice  // Negative for long SL
            else
                pnl := entryPrice - stopLoss  // Negative for short SL
        
        array.set(histPnL, lastIdx, pnl)
        array.set(histExitBar, lastIdx, bar_index)
    
    // Trim history to max size
    if array.size(histResult) > MAX_HISTORY
        array.shift(histDirection)
        array.shift(histEntry)
        array.shift(histTP)
        array.shift(histSL)
        array.shift(histResult)
        array.shift(histPnL)
        array.shift(histEntryBar)
        array.shift(histExitBar)

// Draw exit markers
tpExitNow = tpHit and bar_index == exitBar
slExitNow = slHit and bar_index == exitBar

// TP markers - separate for long/short due to location being input type
plotshape(tpExitNow and entryDirection == 1 and showSignals, title="TP Hit Long", style=shape.xcross, location=location.abovebar, color=color.lime, size=size.small, text="TP ✓")
plotshape(tpExitNow and entryDirection == -1 and showSignals, title="TP Hit Short", style=shape.xcross, location=location.belowbar, color=color.lime, size=size.small, text="TP ✓")

// SL markers - separate for long/short
plotshape(slExitNow and entryDirection == 1 and showSignals, title="SL Hit Long", style=shape.xcross, location=location.belowbar, color=color.red, size=size.small, text="SL ✗")
plotshape(slExitNow and entryDirection == -1 and showSignals, title="SL Hit Short", style=shape.xcross, location=location.abovebar, color=color.red, size=size.small, text="SL ✗")

// Reset for new day
if newTradingDay
    entryTriggered := false
    tradeOpen := false
    entryPrice := na
    stopLoss := na
    takeProfit := na
    entryBar := na
    entryDirection := 0
    tpHit := false
    slHit := false
    exitBar := na
    exitPrice := na

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//// HISTORY TABLE
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

if showHistoryTable
    var table histTable = table.new(position.bottom_left, 6, 13, bgcolor=color.new(color.black, 85), border_color=color.gray, border_width=1, frame_color=color.gray, frame_width=1)
    
    if barstate.islast
        // Header row
        table.cell(histTable, 0, 0, "#", text_color=color.white, text_size=size.tiny, bgcolor=color.new(color.gray, 50))
        table.cell(histTable, 1, 0, "Dir", text_color=color.white, text_size=size.tiny, bgcolor=color.new(color.gray, 50))
        table.cell(histTable, 2, 0, "Entry", text_color=color.white, text_size=size.tiny, bgcolor=color.new(color.gray, 50))
        table.cell(histTable, 3, 0, "Result", text_color=color.white, text_size=size.tiny, bgcolor=color.new(color.gray, 50))
        table.cell(histTable, 4, 0, "P&L", text_color=color.white, text_size=size.tiny, bgcolor=color.new(color.gray, 50))
        table.cell(histTable, 5, 0, "Bars", text_color=color.white, text_size=size.tiny, bgcolor=color.new(color.gray, 50))
        
        // Clear previous rows
        for row = 1 to 12
            for col = 0 to 5
                table.cell(histTable, col, row, "", bgcolor=color.new(color.black, 85))
        
        // Data rows
        int histSize = array.size(histResult)
        int wins = 0
        int losses = 0
        float totalPnL = 0.0
        int openTrades = 0
        
        for i = 0 to math.min(histSize - 1, MAX_HISTORY - 1)
            int idx = histSize - 1 - i  // Reverse order (newest first)
            int row = i + 1
            
            int dir = array.get(histDirection, idx)
            string dirStr = dir == 1 ? "▲ L" : "▼ S"
            color dirCol = dir == 1 ? color.green : color.red
            float entry = array.get(histEntry, idx)
            string result = array.get(histResult, idx)
            float pnl = array.get(histPnL, idx)
            int eBar = array.get(histEntryBar, idx)
            int xBar = array.get(histExitBar, idx)
            int barsHeld = xBar > 0 ? xBar - eBar : bar_index - eBar
            
            color resultCol = result == "TP" ? color.lime : result == "SL" ? color.red : color.orange
            color pnlCol = pnl > 0 ? color.lime : pnl < 0 ? color.red : color.gray
            
            if result == "TP"
                wins += 1
                totalPnL += pnl
            else if result == "SL"
                losses += 1
                totalPnL += pnl
            else
                openTrades += 1
            
            // Format P&L based on price scale
            string pnlStr = result == "OPEN" ? "..." : (pnl >= 0 ? "+" : "") + str.tostring(pnl, format.mintick)
            
            table.cell(histTable, 0, row, str.tostring(i + 1), text_color=color.white, text_size=size.tiny)
            table.cell(histTable, 1, row, dirStr, text_color=dirCol, text_size=size.tiny)
            table.cell(histTable, 2, row, str.tostring(entry, format.mintick), text_color=color.aqua, text_size=size.tiny)
            table.cell(histTable, 3, row, result, text_color=resultCol, text_size=size.tiny)
            table.cell(histTable, 4, row, pnlStr, text_color=pnlCol, text_size=size.tiny)
            table.cell(histTable, 5, row, str.tostring(barsHeld), text_color=color.yellow, text_size=size.tiny)
        
        // Summary row
        int totalClosed = wins + losses
        float winRate = totalClosed > 0 ? (wins / totalClosed) * 100 : 0
        color winRateCol = winRate >= 50 ? color.lime : totalClosed > 0 ? color.red : color.gray
        color totalPnLCol = totalPnL >= 0 ? color.lime : color.red
        
        int summaryRow = math.min(histSize, MAX_HISTORY) + 1
        if histSize > 0
            table.cell(histTable, 0, summaryRow, "TOT", text_color=color.white, text_size=size.tiny, bgcolor=color.new(color.gray, 60))
            table.cell(histTable, 1, summaryRow, str.tostring(wins) + "W/" + str.tostring(losses) + "L", text_color=color.white, text_size=size.tiny, bgcolor=color.new(color.gray, 60))
            table.cell(histTable, 2, summaryRow, "", text_color=color.white, text_size=size.tiny, bgcolor=color.new(color.gray, 60))
            table.cell(histTable, 3, summaryRow, str.tostring(winRate, "#.#") + "%", text_color=winRateCol, text_size=size.tiny, bgcolor=color.new(color.gray, 60))
            table.cell(histTable, 4, summaryRow, (totalPnL >= 0 ? "+" : "") + str.tostring(totalPnL, format.mintick), text_color=totalPnLCol, text_size=size.tiny, bgcolor=color.new(color.gray, 60))
            table.cell(histTable, 5, summaryRow, "", text_color=color.white, text_size=size.tiny, bgcolor=color.new(color.gray, 60))

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//// STATUS TABLE
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

if showStatusTable
    var table infoTable = table.new(position.top_right, 2, 7, bgcolor=color.new(color.black, 80), border_color=color.gray, border_width=1)
    
    if barstate.islast
        table.cell(infoTable, 0, 0, "FCR Status", text_color=color.white, text_size=size.small)
        table.cell(infoTable, 1, 0, fcrEstablished ? "✓ Set" : "Waiting", text_color=fcrEstablished ? color.green : color.orange, text_size=size.small)
        
        table.cell(infoTable, 0, 1, "FCR High", text_color=color.white, text_size=size.small)
        table.cell(infoTable, 1, 1, not na(fcrHigh) ? str.tostring(fcrHigh, format.mintick) : "-", text_color=color.aqua, text_size=size.small)
        
        table.cell(infoTable, 0, 2, "FCR Low", text_color=color.white, text_size=size.small)
        table.cell(infoTable, 1, 2, not na(fcrLow) ? str.tostring(fcrLow, format.mintick) : "-", text_color=color.aqua, text_size=size.small)
        
        table.cell(infoTable, 0, 3, "Breakout", text_color=color.white, text_size=size.small)
        table.cell(infoTable, 1, 3, breakoutDirection == 1 ? "▲ Bull" : breakoutDirection == -1 ? "▼ Bear" : "None", text_color=breakoutDirection == 1 ? color.green : breakoutDirection == -1 ? color.red : color.gray, text_size=size.small)
        
        table.cell(infoTable, 0, 4, "FVG", text_color=color.white, text_size=size.small)
        table.cell(infoTable, 1, 4, fvgEstablished ? "✓ Found" : "Waiting", text_color=fvgEstablished ? color.green : color.orange, text_size=size.small)
        
        table.cell(infoTable, 0, 5, "Retest", text_color=color.white, text_size=size.small)
        table.cell(infoTable, 1, 5, retestOccurred ? "✓ Yes" : "Waiting", text_color=retestOccurred ? color.green : color.orange, text_size=size.small)
        
        string tradeStatus = tradeOpen ? "OPEN" : tpHit ? "TP ✓" : slHit ? "SL ✗" : entryTriggered ? "Closed" : "No Entry"
        color tradeCol = tradeOpen ? color.yellow : tpHit ? color.lime : slHit ? color.red : color.gray
        table.cell(infoTable, 0, 6, "Trade", text_color=color.white, text_size=size.small)
        table.cell(infoTable, 1, 6, tradeStatus, text_color=tradeCol, text_size=size.small)

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//// ALERTS
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

alertcondition(bullishBreakout, title="Bullish Breakout", message="FCR: Bullish breakout on {{ticker}}")
alertcondition(bearishBreakout, title="Bearish Breakout", message="FCR: Bearish breakout on {{ticker}}")
alertcondition(entrySignal and entryDirection == 1, title="Buy Entry", message="FCR: Buy entry on {{ticker}} at {{close}}")
alertcondition(entrySignal and entryDirection == -1, title="Sell Entry", message="FCR: Sell entry on {{ticker}} at {{close}}")
alertcondition(tpExitNow, title="Take Profit", message="FCR: TP hit on {{ticker}}")
alertcondition(slExitNow, title="Stop Loss", message="FCR: SL hit on {{ticker}}")
